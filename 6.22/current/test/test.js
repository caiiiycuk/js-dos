(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// Autogenerated
// -------------
// gulpfile.js --> generateBuildInfo

Object.defineProperty(exports, "__esModule", { value: true });
exports.Build = {
    version: "6.22.28 (721fcbc75f96c013b4f8f570a246e17a)",
    jsVersion: "3fd256cd8a6abf949442964503a6c90d8270f064",
    jsSize: 468455,
    wasmVersion: "d9f429891f4b5026d1dacb873f8f7a2a",
    wasmSize: 2140358
};

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CacheDb = /** @class */function () {
    function CacheDb(version, onready, onerror) {
        var _this = this;
        this.storeName = "files";
        this.db = null;
        this.version = version;
        this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        if (!this.indexedDB) {
            onerror("Indexed db is not supported on this host");
            return;
        }
        var openRequest = this.indexedDB.open("js-dos-cache (" + version + ")", 1);
        openRequest.onerror = function (event) {
            onerror("Can't open cache database");
        };
        openRequest.onsuccess = function (event) {
            _this.db = openRequest.result;
            onready(_this);
        };
        openRequest.onupgradeneeded = function (event) {
            try {
                _this.db = openRequest.result;
                _this.db.onerror = function (event) {
                    onerror("Can't upgrade cache database");
                };
                _this.db.createObjectStore(_this.storeName);
            } catch (e) {
                onerror("Can't upgrade cache database");
            }
        };
    }
    CacheDb.prototype.put = function (key, data, onflush) {
        if (this.db === null) {
            onflush();
            return;
        }
        var transaction = this.db.transaction(this.storeName, "readwrite");
        transaction.oncomplete = function () {
            return onflush();
        };
        transaction.objectStore(this.storeName).put(data, key);
    };
    CacheDb.prototype.get = function (key, ondata, onerror) {
        if (this.db === null) {
            onerror("db is not initalized");
            return;
        }
        var transaction = this.db.transaction(this.storeName, "readonly");
        var request = transaction.objectStore(this.storeName).get(key);
        request.onerror = function () {
            return onerror("Can't read value for key '" + key + "'");
        };
        request.onsuccess = function () {
            if (request.result) {
                ondata(request.result);
            } else {
                onerror("Result is empty for key '" + key + "', result: " + request.result);
            }
        };
    };
    CacheDb.prototype.forEach = function (each, onend) {
        if (this.db === null) {
            onend();
            return;
        }
        var transaction = this.db.transaction(this.storeName, "readonly");
        var request = transaction.objectStore(this.storeName).openCursor();
        request.onerror = function () {
            return onend();
        };
        request.onsuccess = function (event) {
            var cursor = event.target.result;
            if (cursor) {
                each(cursor.key.toString(), cursor.value);
                cursor.continue();
            } else {
                onend();
            }
        };
    };
    return CacheDb;
}();
exports.default = CacheDb;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CacheNoop = /** @class */function () {
    function CacheNoop() {}
    CacheNoop.prototype.put = function (key, data, onflush) {
        // nothing
    };
    CacheNoop.prototype.get = function (key, ondata, onerror) {
        onerror("Cache is not supported on this host");
    };
    CacheNoop.prototype.forEach = function (each, onend) {
        onend();
    };
    return CacheNoop;
}();
exports.default = CacheNoop;

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var js_dos_cache_db_1 = require("./js-dos-cache-db");
var js_dos_cache_noop_1 = require("./js-dos-cache-noop");
function openCache(module, onready) {
    new js_dos_cache_db_1.default(module.version, onready, function (msg) {
        if (module.log !== undefined) {
            module.log("ERR! Can't initalize cache, cause: " + msg);
        }
        onready(new js_dos_cache_noop_1.default());
    });
}
exports.default = openCache;

},{"./js-dos-cache-db":2,"./js-dos-cache-noop":3}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DosCommandInterface = /** @class */function () {
    function DosCommandInterface(dos, onready) {
        var _this = this;
        this.shellInputQueue = [];
        this.shellInputClients = [];
        this.dos = dos;
        this.em = dos;
        this.api = dos;
        this.api.ping = function (msg) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            _this.onping(msg, args);
        };
        this.onready = onready;
    }
    // * `width()` - return dosbox window width in pixels
    DosCommandInterface.prototype.width = function () {
        return this.dos.canvas.width;
    };
    // * `height()` - return dosbox window height in pixels
    DosCommandInterface.prototype.height = function () {
        return this.dos.canvas.height;
    };
    // * `shell([cmd1, cmd2, ...])` - executes passed commands
    // in dosbox shell if it's runned, returns Promise that
    // resolves when commands sequence is executed
    DosCommandInterface.prototype.shell = function () {
        var _this = this;
        var cmd = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            cmd[_i] = arguments[_i];
        }
        if (cmd.length === 0) {
            return;
        }
        return new Promise(function (resolve, reject) {
            _this.shellInputClients.push(resolve);
            for (var _i = 0, cmd_1 = cmd; _i < cmd_1.length; _i++) {
                var next = cmd_1[_i];
                _this.shellInputQueue.push(next);
            }
            _this.requestShellInput();
        });
    };
    // * `screenshot()` - get screnshot of canvas as ImageData
    DosCommandInterface.prototype.screenshot = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.api.send("screenshot", "", function (data) {
                resolve(data);
            });
        });
    };
    // * `exit()` - immediately exit from runtime
    DosCommandInterface.prototype.exit = function () {
        try {
            this.dos.terminate();
            this.api.send("exit");
        } catch (e) {
            return 0;
        }
        this.dos.error("Runtime is still alive!");
        return -1;
    };
    DosCommandInterface.prototype.sendKeyPress = function (code) {
        this.api.send("sdl_key_event", code + "");
    };
    DosCommandInterface.prototype.requestShellInput = function () {
        this.sendKeyPress(13);
    };
    DosCommandInterface.prototype.onping = function (msg, args) {
        switch (msg) {
            case "ready":
                this.onready(this);
                break;
            case "frame":
                this.onframe();
                break;
            case "shell_input":
                if (this.shellInputQueue.length === 0) {
                    return;
                }
                var buffer = args[0];
                var maxLength = args[1];
                var cmd = this.shellInputQueue.shift();
                var cmdLength = this.em.lengthBytesUTF8(cmd) + 1;
                if (cmdLength > maxLength) {
                    if (this.dos.onerror !== undefined) {
                        this.dos.onerror("Can't execute cmd '" + cmd + "', because it's bigger then max cmd length " + maxLength);
                    }
                    return;
                }
                this.em.stringToUTF8(cmd, buffer, cmdLength);
                if (this.shellInputQueue.length === 0) {
                    for (var _i = 0, _a = this.shellInputClients; _i < _a.length; _i++) {
                        var resolve = _a[_i];
                        resolve();
                    }
                    this.shellInputClients = [];
                } else {
                    this.requestShellInput();
                }
            default:
            /* do nothing */
        }
    };
    DosCommandInterface.prototype.onframe = function () {
        this.dos.tick();
    };
    return DosCommandInterface;
}();
exports.DosCommandInterface = DosCommandInterface;

},{}],6:[function(require,module,exports){
"use strict";
// # js-dos default config
// This is default config for dosbox.

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
exports.jsdosconf = "\n# This is the configurationfile for DOSBox 0.74. (Please use the latest version of DOSBox)\n# Lines starting with a # are commentlines and are ignored by DOSBox.\n# They are used to (briefly) document the effect of each option.\n\n[sdl]\n#       fullscreen: Start dosbox directly in fullscreen. (Press ALT-Enter to go back)\n#       fulldouble: Use double buffering in fullscreen. It can reduce screen flickering, but it can also result in a slow DOSBox.\n#   fullresolution: What resolution to use for fullscreen: original or fixed size (e.g. 1024x768).\n#                     Using your monitor's native resolution with aspect=true might give the best results.\n#                     If you end up with small window on a large screen, try an output different from surface.\n# windowresolution: Scale the window to this size IF the output device supports hardware scaling.\n#                     (output=surface does not!)\n#           output: What video system to use for output.\n#                   Possible values: surface, overlay, opengl, openglnb.\n#         autolock: Mouse will automatically lock, if you click on the screen. (Press CTRL-F10 to unlock)\n#      sensitivity: Mouse sensitivity.\n#      waitonerror: Wait before closing the console if dosbox has an error.\n#         priority: Priority levels for dosbox. Second entry behind the comma is for when dosbox is not focused/minimized.\n#                     pause is only valid for the second entry.\n#                   Possible values: lowest, lower, normal, higher, highest, pause.\n#       mapperfile: File used to load/save the key/event mappings from. Resetmapper only works with the defaul value.\n#     usescancodes: Avoid usage of symkeys, might not work on all operating systems.\n\nfullscreen=false\nfulldouble=false\nfullresolution=original\nwindowresolution=original\noutput=surface\nautolock=false\nsensitivity=100\nwaitonerror=true\npriority=higher,normal\nmapperfile=mapper-jsdos.map\nusescancodes=true\nvsync=false\n\n[dosbox]\n# language: Select another language file.\n#  machine: The type of machine tries to emulate.\n#           Possible values: hercules, cga, tandy, pcjr, ega, vgaonly, svga_s3, svga_et3000, svga_et4000, svga_paradise, vesa_nolfb, vesa_oldvbe.\n# captures: Directory where things like wave, midi, screenshot get captured.\n#  memsize: Amount of memory DOSBox has in megabytes.\n#             This value is best left at its default to avoid problems with some games,\n#             though few games might require a higher value.\n#             There is generally no speed advantage when raising this value.\n\nlanguage=\nmachine=svga_s3\ncaptures=capture\nmemsize=16\n\n[render]\n# frameskip: How many frames DOSBox skips before drawing one.\n#    aspect: Do aspect correction, if your output method doesn't support scaling this can slow things down!.\n#    scaler: Scaler used to enlarge/enhance low resolution modes.\n#              If 'forced' is appended, then the scaler will be used even if the result might not be desired.\n#            Possible values: none, normal2x, normal3x, advmame2x, advmame3x, advinterp2x, advinterp3x, hq2x, hq3x, 2xsai, super2xsai, supereagle, tv2x, tv3x, rgb2x, rgb3x, scan2x, scan3x.\n\nframeskip=0\naspect=false\nscaler=none\n\n[cpu]\n#      core: CPU Core used in emulation. auto will switch to dynamic if available and appropriate.\n#            Possible values: auto, dynamic, normal, simple.\n#   cputype: CPU Type used in emulation. auto is the fastest choice.\n#            Possible values: auto, 386, 386_slow, 486_slow, pentium_slow, 386_prefetch.\n#    cycles: Amount of instructions DOSBox tries to emulate each millisecond.\n#            Setting this value too high results in sound dropouts and lags.\n#            Cycles can be set in 3 ways:\n#              'auto'          tries to guess what a game needs.\n#                              It usually works, but can fail for certain games.\n#              'fixed #number' will set a fixed amount of cycles. This is what you usually need if 'auto' fails.\n#                              (Example: fixed 4000).\n#              'max'           will allocate as much cycles as your computer is able to handle.\n#\n#            Possible values: auto, fixed, max.\n#   cycleup: Amount of cycles to decrease/increase with keycombo.(CTRL-F11/CTRL-F12)\n# cycledown: Setting it lower than 100 will be a percentage.\n\ncore=auto\ncputype=auto\ncycles=auto\ncycleup=10\ncycledown=20\n\n[mixer]\n#   nosound: Enable silent mode, sound is still emulated though.\n#      rate: Mixer sample rate, setting any device's rate higher than this will probably lower their sound quality.\n#            Possible values: 44100, 48000, 32000, 22050, 16000, 11025, 8000, 49716.\n# blocksize: Mixer block size, larger blocks might help sound stuttering but sound will also be more lagged.\n#            Possible values: 1024, 2048, 4096, 8192, 512, 256.\n# prebuffer: How many milliseconds of data to keep on top of the blocksize.\n\nnosound=false\nrate=44100\nblocksize=1024\nprebuffer=20\n\n[midi]\n#     mpu401: Type of MPU-401 to emulate.\n#             Possible values: intelligent, uart, none.\n# mididevice: Device that will receive the MIDI data from MPU-401.\n#             Possible values: default, win32, alsa, oss, coreaudio, coremidi, none.\n# midiconfig: Special configuration options for the device driver. This is usually the id of the device you want to use.\n#               See the README/Manual for more details.\n\nmpu401=intelligent\nmididevice=default\nmidiconfig=\n\n[sblaster]\n#  sbtype: Type of Soundblaster to emulate. gb is Gameblaster.\n#          Possible values: sb1, sb2, sbpro1, sbpro2, sb16, gb, none.\n#  sbbase: The IO address of the soundblaster.\n#          Possible values: 220, 240, 260, 280, 2a0, 2c0, 2e0, 300.\n#     irq: The IRQ number of the soundblaster.\n#          Possible values: 7, 5, 3, 9, 10, 11, 12.\n#     dma: The DMA number of the soundblaster.\n#          Possible values: 1, 5, 0, 3, 6, 7.\n#    hdma: The High DMA number of the soundblaster.\n#          Possible values: 1, 5, 0, 3, 6, 7.\n# sbmixer: Allow the soundblaster mixer to modify the DOSBox mixer.\n# oplmode: Type of OPL emulation. On 'auto' the mode is determined by sblaster type. All OPL modes are Adlib-compatible, except for 'cms'.\n#          Possible values: auto, cms, opl2, dualopl2, opl3, none.\n#  oplemu: Provider for the OPL emulation. compat might provide better quality (see oplrate as well).\n#          Possible values: default, compat, fast.\n# oplrate: Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).\n#          Possible values: 44100, 49716, 48000, 32000, 22050, 16000, 11025, 8000.\n\nsbtype=sb16\nsbbase=220\nirq=7\ndma=1\nhdma=5\nsbmixer=true\noplmode=auto\noplemu=default\noplrate=44100\n\n[gus]\n#      gus: Enable the Gravis Ultrasound emulation.\n#  gusrate: Sample rate of Ultrasound emulation.\n#           Possible values: 44100, 48000, 32000, 22050, 16000, 11025, 8000, 49716.\n#  gusbase: The IO base address of the Gravis Ultrasound.\n#           Possible values: 240, 220, 260, 280, 2a0, 2c0, 2e0, 300.\n#   gusirq: The IRQ number of the Gravis Ultrasound.\n#           Possible values: 5, 3, 7, 9, 10, 11, 12.\n#   gusdma: The DMA channel of the Gravis Ultrasound.\n#           Possible values: 3, 0, 1, 5, 6, 7.\n# ultradir: Path to Ultrasound directory. In this directory\n#           there should be a MIDI directory that contains\n#           the patch files for GUS playback. Patch sets used\n#           with Timidity should work fine.\n\ngus=false\ngusrate=44100\ngusbase=240\ngusirq=5\ngusdma=3\nultradir=C:ULTRASND\n\n[speaker]\n# pcspeaker: Enable PC-Speaker emulation.\n#    pcrate: Sample rate of the PC-Speaker sound generation.\n#            Possible values: 44100, 48000, 32000, 22050, 16000, 11025, 8000, 49716.\n#     tandy: Enable Tandy Sound System emulation. For 'auto', emulation is present only if machine is set to 'tandy'.\n#            Possible values: auto, on, off.\n# tandyrate: Sample rate of the Tandy 3-Voice generation.\n#            Possible values: 44100, 48000, 32000, 22050, 16000, 11025, 8000, 49716.\n#    disney: Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).\n\npcspeaker=true\npcrate=44100\ntandy=auto\ntandyrate=44100\ndisney=true\n\n[joystick]\n# joysticktype: Type of joystick to emulate: auto (default), none,\n#               2axis (supports two joysticks),\n#               4axis (supports one joystick, first joystick used),\n#               4axis_2 (supports one joystick, second joystick used),\n#               fcs (Thrustmaster), ch (CH Flightstick).\n#               none disables joystick emulation.\n#               auto chooses emulation depending on real joystick(s).\n#               (Remember to reset dosbox's mapperfile if you saved it earlier)\n#               Possible values: auto, 2axis, 4axis, 4axis_2, fcs, ch, none.\n#        timed: enable timed intervals for axis. Experiment with this option, if your joystick drifts (away).\n#     autofire: continuously fires as long as you keep the button pressed.\n#       swap34: swap the 3rd and the 4th axis. can be useful for certain joysticks.\n#   buttonwrap: enable button wrapping at the number of emulated buttons.\n\njoysticktype=auto\ntimed=true\nautofire=false\nswap34=false\nbuttonwrap=false\n\n[serial]\n# serial1: set type of device connected to com port.\n#          Can be disabled, dummy, modem, nullmodem, directserial.\n#          Additional parameters must be in the same line in the form of\n#          parameter:value. Parameter for all types is irq (optional).\n#          for directserial: realport (required), rxdelay (optional).\n#                           (realport:COM1 realport:ttyS0).\n#          for modem: listenport (optional).\n#          for nullmodem: server, rxdelay, txdelay, telnet, usedtr,\n#                         transparent, port, inhsocket (all optional).\n#          Example: serial1=modem listenport:5000\n#          Possible values: dummy, disabled, modem, nullmodem, directserial.\n# serial2: see serial1\n#          Possible values: dummy, disabled, modem, nullmodem, directserial.\n# serial3: see serial1\n#          Possible values: dummy, disabled, modem, nullmodem, directserial.\n# serial4: see serial1\n#          Possible values: dummy, disabled, modem, nullmodem, directserial.\n\nserial1=dummy\nserial2=dummy\nserial3=disabled\nserial4=disabled\n\n[dos]\n#            xms: Enable XMS support.\n#            ems: Enable EMS support.\n#            umb: Enable UMB support.\n# keyboardlayout: Language code of the keyboard layout (or none).\n\nxms=true\nems=true\numb=true\nkeyboardlayout=auto\n\n[ipx]\n# ipx: Enable ipx over UDP/IP emulation.\n\nipx=false\n\n[autoexec]\n# Lines in this section will be run at startup.\n# You can put your MOUNT lines here.\n\n# https://js-dos.com\n# \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2588  \u2584\u2584\u2584\u2580\u2580\u2588 \u2588\u2580\u2580\u2580\u2580\u2580\u2588\n# \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\u2584 \u2588 \u2580 \u2584 \u2588 \u2588\u2588\u2588 \u2588\n# \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2588\u2588 \u2580 \u2580\u2580\u2588 \u2588 \u2580\u2580\u2580 \u2588\n# \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580 \u2588\u2584\u2580\u2584\u2580 \u2588 \u2580\u2580\u2580\u2580\u2580\u2580\u2580\n# \u2588\u2580\u2584\u2584\u2588\u2580\u2580\u2584\u2584 \u2580 \u2580\u2588\u2584\u2584\u2584\u2584 \u2580\u2584\u2588\u2580\u2588\u2580\n# \u2588\u2580 \u2580 \u2580\u2580\u2584 \u2588\u2580 \u2584 \u2584\u2580\u2580\u2580\u2584 \u2588\u2580\u2588\u2584\n# \u2584 \u2584\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2584\u2580\u2580\u2588  \u2580\u2580\u2584\u2580\u2580\u2588\u2580\n#   \u2584\u2580\u2580\u2588\u2580\u2580 \u2588\u2580\u2588\u2580\u2588\u2580\u2580\u2584 \u2580\u2588\u2588\u2580\u2588\u2584\n# \u2580\u2580\u2580 \u2580 \u2580 \u2588\u2584\u2588 \u2580\u2588\u2584\u2584\u2588\u2580\u2580\u2580\u2588\u2580\u2580\n# \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2584\u2584\u2584 \u2584 \u2584 \u2588 \u2580 \u2588\u2584\u2584\u2584\u2584\n# \u2588 \u2588\u2588\u2588 \u2588 \u2580\u2588\u2580\u2580\u2584\u2580\u2580\u2584\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2584\u2588\n# \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2580\u2580\u2588\u2580\u2588\u2580\u2584 \u2580\u2580\u2584\u2584\u2588\u2584\u2588 \n# \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580   \u2580\u2580 \u2580  \u2580   \u2580\u2580\u2580\n";

},{}],7:[function(require,module,exports){
"use strict";
// # DosFS
// API for working with file system of dosbox

Object.defineProperty(exports, "__esModule", { value: true });
var js_dos_cache_noop_1 = require("./js-dos-cache-noop");
var js_dos_xhr_1 = require("./js-dos-xhr");
var DosFS = /** @class */function () {
    function DosFS(dos) {
        var _this = this;
        this.syncingPromise = null;
        this.lastSyncTime = 0;
        this.dos = dos;
        this.em = dos;
        this.fs = dos.FS;
        // Sync fs to indexed db periodically
        this.dos.registerTickListener(function () {
            if (Date.now() - _this.lastSyncTime < 5000) {
                return;
            }
            _this.lastSyncTime = Date.now();
            _this.syncFs();
        });
        this.dos.registerPauseListener(function () {
            return _this.syncFs();
        });
        this.dos.registerTerminateListener(function () {
            return _this.syncFs();
        });
    }
    DosFS.prototype.chdir = function (path) {
        this.fs.chdir(path);
    };
    // ### extract
    DosFS.prototype.extract = function (url, persistentMount, type) {
        // download archive by given url and then extract it in cwd (cwd will be mounted as C:)
        //
        // * `url` - url for downloading archive
        // * `persistentMount` - is a path to mount archive contents, by default mount point is '/' which
        // is a MEMFS that is live only in one ssesion. It means that after restart all progress will be erased.
        // If you set some path (any), then this path will be stored across sessions in indexed db. It means
        // that progress will be there after browser restart.
        // * `type` - archive type **only zip is supported**
        //
        // this method will return `Promise<void>`, that will be resolved
        // on success with empty object or rejected
        var _this = this;
        if (persistentMount === void 0) {
            persistentMount = "/";
        }
        if (type === void 0) {
            type = "zip";
        }
        persistentMount = this.normalizePath(persistentMount);
        var parts = persistentMount.split("/");
        this.createPath(parts, 0, parts.length);
        this.chdir(persistentMount);
        var extractArchiveInCwd = function extractArchiveInCwd() {
            return new Promise(function (resolve, reject) {
                if (type !== "zip") {
                    reject("Only ZIP archive is supported");
                    return;
                }
                new js_dos_xhr_1.Xhr(url, {
                    cache: new js_dos_cache_noop_1.default(),
                    responseType: "arraybuffer",
                    fail: function fail(msg) {
                        return reject(msg);
                    },
                    progress: function progress(total, loaded) {
                        if (_this.dos.onprogress !== undefined) {
                            _this.dos.onprogress("Downloading " + url, total, loaded);
                        }
                    },
                    success: function success(data) {
                        var bytes = new Uint8Array(data);
                        var buffer = _this.em._malloc(bytes.length);
                        _this.em.HEAPU8.set(bytes, buffer);
                        var retcode = _this.em._extract_zip(buffer, bytes.length);
                        _this.em._free(buffer);
                        if (retcode === 0) {
                            _this.writeOk(persistentMount);
                            _this.syncFs().then(resolve).catch(reject);
                        } else {
                            reject("Can't extract zip, retcode " + retcode + ", see more info in logs");
                        }
                    }
                });
            });
        };
        if (persistentMount === "/" || persistentMount.length === 0) {
            return extractArchiveInCwd();
        }
        return new Promise(function (resolve, reject) {
            if (_this.lastSyncTime > 0) {
                reject("Can't create persistent mount point, after syncing process starts");
                return;
            }
            _this.fs.mount(_this.fs.filesystems.IDBFS, {}, persistentMount);
            _this.fs.syncfs(true, function (err) {
                if (err) {
                    reject("Can't restore FS from indexed db, cause: " + err);
                    return;
                }
                if (!_this.readOk(persistentMount)) {
                    _this.dos.warn("Indexed db contains broken FS, resetting...");
                    extractArchiveInCwd().then(resolve).catch(reject);
                    return;
                }
                resolve();
            });
        });
    };
    // ### createFile
    DosFS.prototype.createFile = function (file, body) {
        // [synchronous] allow to create file in FS, you can pass absolute path.
        // All directories will be created
        //
        // body can be string or ArrayBuffer or Uint8Array
        if (body instanceof ArrayBuffer) {
            body = new Uint8Array(body);
        }
        // windows style path are also valid, but **drive letter is ignored**
        // if you pass only filename, then file will be writed in root "/" directory
        file = file.replace(new RegExp("^[a-zA-z]+:"), "").replace(new RegExp("\\\\", "g"), "/");
        var parts = file.split("/");
        if (parts.length === 0) {
            if (this.dos.onerror !== undefined) {
                this.dos.onerror("Can't create file '" + file + "', because it's not valid file path");
            }
            return;
        }
        var filename = parts[parts.length - 1].trim();
        if (filename.length === 0) {
            if (this.dos.onerror !== undefined) {
                this.dos.onerror("Can't create file '" + file + "', because file name is empty");
            }
            return;
        }
        /* i < parts.length - 1, because last part is file name */
        var path = this.createPath(parts, 0, parts.length - 1);
        this.fs.createDataFile(path, filename, body, true, true, true);
    };
    DosFS.prototype.createPath = function (parts, begin, end) {
        var path = "";
        for (var i = begin; i < end; ++i) {
            var part = parts[i].trim();
            if (part.length === 0) {
                continue;
            }
            this.fs.createPath(path, part, true, true);
            path = path + "/" + part;
        }
        return path;
    };
    DosFS.prototype.syncFs = function () {
        var _this = this;
        if (this.syncingPromise) {
            return this.syncingPromise;
        }
        this.syncingPromise = new Promise(function (resolve, reject) {
            var startedAt = Date.now();
            _this.fs.syncfs(false, function (err) {
                if (err) {
                    _this.dos.error("Can't sync FS to indexed db, cause: " + err);
                    reject(err);
                }
                _this.syncingPromise = null;
                _this.lastSyncTime = Date.now();
                resolve();
            });
        });
        return this.syncingPromise;
    };
    DosFS.prototype.normalizePath = function (path) {
        if (path.length === 0 || path[0] !== "/") {
            path = "/" + path;
        }
        if (path.length > 1 && path.endsWith("/")) {
            path = path.substr(0, path.length - 1);
        }
        return path;
    };
    DosFS.prototype.readOk = function (path) {
        try {
            var readed = this.fs.readFile(path + "/state.fs");
            return readed[0] === 79 && readed[1] === 70;
        } catch (_a) {
            return false;
        }
    };
    DosFS.prototype.writeOk = function (path) {
        this.createFile(path + "/state.fs", new Uint8Array([79, 70])); // Ok
    };
    return DosFS;
}();
exports.DosFS = DosFS;

},{"./js-dos-cache-noop":3,"./js-dos-xhr":12}],8:[function(require,module,exports){
"use strict";
// # DosHost
// This class is used to detect and provide information about
// features that supported in current environment

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:member-ordering */
var js_dos_build_1 = require("./js-dos-build");
var js_dos_xhr_1 = require("./js-dos-xhr");
var DosHost = /** @class */function () {
    function DosHost() {
        this.wasmSupported = false;
        this.global = window;
        this.wdosboxPromise = null;
        this.global.exports = {};
        // ### WebAssembly
        // Host able to detect is WebAssembly supported or not,
        // this information is stored in `Host.wasmSupported` variable
        try {
            if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === "object" && typeof WebAssembly.instantiate === "function" && typeof WebAssembly.compile === "function") {
                var wmodule = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
                if (wmodule instanceof WebAssembly.Module) {
                    this.wasmSupported = new WebAssembly.Instance(wmodule) instanceof WebAssembly.Instance;
                }
            }
        } catch (error) {}
        /* do nothing WebAssembly is not supported */

        // ### polyfill
        // Host also provides limited set of polyfills to support legacy browsers
        this.polyfill();
    }
    // Currently polyfill contains implementations for:
    // `Math.imul`, `Math.fround`, `Math.clz32`, `Math.trunc`
    /* tslint:disable:no-bitwise */
    /* tslint:disable:only-arrow-functions */
    DosHost.prototype.polyfill = function () {
        if (!Math.imul || Math.imul(0xffffffff, 5) !== -5) {
            Math.imul = function imul(a, b) {
                var ah = a >>> 16;
                var al = a & 0xffff;
                var bh = b >>> 16;
                var bl = b & 0xffff;
                return al * bl + (ah * bl + al * bh << 16) | 0;
            };
        }
        Math.imul = Math.imul;
        if (!Math.fround) {
            Math.fround = function (x) {
                return x;
            };
        }
        Math.fround = Math.fround;
        if (!Math.clz32) {
            Math.clz32 = function (x) {
                x = x >>> 0;
                for (var i = 0; i < 32; i++) {
                    if (x & 1 << 31 - i) {
                        return i;
                    }
                }
                return 32;
            };
        }
        Math.clz32 = Math.clz32;
        if (!Math.trunc) {
            Math.trunc = function (x) {
                return x < 0 ? Math.ceil(x) : Math.floor(x);
            };
        }
        Math.trunc = Math.trunc;
    };
    // ### resolveDosBox
    // `resolveDosBox` is another important task of DosHost
    DosHost.prototype.resolveDosBox = function (url, cache, module) {
        var _this = this;
        // When dosbox is resolved, WDOSBOX module is set to
        // global variable `exports.WDOSBOX`. This variable is
        // used to prevent next loads of same dosbox module.
        if (this.global.exports.WDOSBOX) {
            module.ondosbox(this.global.exports.WDOSBOX, this.global.exports.instantiateWasm);
            return;
        }
        if (!this.wasmSupported) {
            if (module.onerror !== undefined) {
                module.onerror("WebAssembly is not supported, can't resolve wdosbox");
            }
            return;
        }
        if (this.wdosboxPromise === null) {
            this.wdosboxPromise = this.compileDosBox(url, cache, module);
        }
        this.wdosboxPromise.then(function (instance) {
            /* leave promise scope */
            var fn = function fn() {
                _this.wdosboxPromise = null;
                module.ondosbox(_this.global.exports.WDOSBOX, _this.global.exports.instantiateWasm);
            };
            setTimeout(fn, 1);
        }, function (message) {
            /* leave promise scope */
            var fn = function fn() {
                _this.wdosboxPromise = null;
                if (module.onerror !== undefined) {
                    module.onerror(message);
                }
            };
            setTimeout(fn, 1);
        });
    };
    // If dosbox is not yet resolved, then:
    DosHost.prototype.compileDosBox = function (url, cache, module) {
        var _this = this;
        var buildTotal = js_dos_build_1.Build.wasmSize + js_dos_build_1.Build.jsSize;
        return new Promise(function (resolve, reject) {
            var wasmUrl = url.replace(".js", ".wasm.js");
            // * Host downloads `wdosbox` asm + js scripts
            new js_dos_xhr_1.Xhr(wasmUrl, {
                cache: cache,
                responseType: "arraybuffer",
                progress: function progress(total, loaded) {
                    if (module.onprogress) {
                        module.onprogress("Resolving DosBox", buildTotal, loaded);
                    }
                },
                fail: function fail(url, status, message) {
                    reject("Can't download wasm, code: " + status + ", message: " + message + ", url: " + url);
                },
                success: function success(response) {
                    // * Compile dosbox wasm module
                    var promise = WebAssembly.compile(response);
                    var onreject = function onreject(reason) {
                        reject(reason + "");
                    };
                    promise.catch(onreject);
                    promise.then(function (wasmModule) {
                        _this.global.exports.instantiateWasm = function (info, receiveInstance) {
                            info.env.globalscall = function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                if (module.onglobals) {
                                    module.onglobals.apply(null, args);
                                }
                            };
                            // *  Instaniate it for each new dosbox runtime
                            return WebAssembly.instantiate(wasmModule, info).catch(onreject).then(function (instance) {
                                receiveInstance(instance, wasmModule);
                            });
                        };
                        new js_dos_xhr_1.Xhr(url, {
                            cache: cache,
                            progress: function progress(total, loaded) {
                                if (module.onprogress) {
                                    module.onprogress("Resolving DosBox", buildTotal, js_dos_build_1.Build.wasmSize + loaded);
                                }
                            },
                            fail: function fail(url, status, message) {
                                reject("Can't download wdosbox.js, code: " + status + ", message: " + message + ", url: " + url);
                            },
                            success: function success(response) {
                                if (module.onprogress !== undefined) {
                                    module.onprogress("Resolving DosBox", buildTotal, buildTotal);
                                }
                                response +=
                                /* tslint:disable:no-eval */
                                eval.call(window, response);
                                /* tslint:enable:no-eval */
                                resolve(_this.global.exports.WDOSBOX);
                            }
                        });
                    });
                }
            });
        });
    };
    return DosHost;
}();
exports.Host = new DosHost();

},{"./js-dos-build":1,"./js-dos-xhr":12}],9:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var js_dos_build_1 = require("./js-dos-build");
var js_dos_ci_1 = require("./js-dos-ci");
var js_dos_conf_1 = require("./js-dos-conf");
var js_dos_fs_1 = require("./js-dos-fs");
var js_dos_options_1 = require("./js-dos-options");
var js_dos_ui_1 = require("./js-dos-ui");
var DosModule = /** @class */function (_super) {
    __extends(DosModule, _super);
    function DosModule(canvas, onready) {
        var _this = _super.call(this) || this;
        _this.isValid = false;
        _this.version = js_dos_build_1.Build.version;
        _this.ci = null;
        _this.fs = null;
        _this.ui = null;
        _this.tickListeners = [];
        _this.pauseListeners = [];
        _this.resumeListeners = [];
        _this.terminateListeners = [];
        _this.canvas = canvas;
        _this.onready = onready;
        _this.registerDefaultListeners();
        return _this;
    }
    DosModule.prototype.registerDefaultListeners = function () {
        var _this = this;
        var hidden;
        var visibilityChange;
        if (typeof document.hidden !== "undefined") {
            hidden = "hidden";
            visibilityChange = "visibilitychange";
        } else if (typeof document.mozHidden !== "undefined") {
            hidden = "mozHidden";
            visibilityChange = "mozvisibilitychange";
        } else if (typeof document.msHidden !== "undefined") {
            hidden = "msHidden";
            visibilityChange = "msvisibilitychange";
        } else if (typeof document.webkitHidden !== "undefined") {
            hidden = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
        }
        document.addEventListener("visibilityChange", function () {
            document[hidden] ? _this.pause() : _this.resume();
        }, false);
        window.addEventListener("beforeunload", function () {
            _this.terminate();
        });
    };
    // ### logging
    // DosModule implements simply logging features:
    // `debug`, `info`, `warn`, `error` methods
    DosModule.prototype.debug = function (message) {
        if (this.log !== undefined) {
            this.log("[DEBUG] " + message);
        }
    };
    DosModule.prototype.info = function (message) {
        if (this.log !== undefined) {
            this.log("[INFO] " + message);
        }
    };
    DosModule.prototype.warn = function (message) {
        if (this.log !== undefined) {
            this.log("[WARN] " + message);
        }
    };
    DosModule.prototype.error = function (message) {
        if (this.log !== undefined) {
            this.log("[ERROR] " + message);
        }
    };
    // ### ondosbox
    DosModule.prototype.ondosbox = function (dosbox, instantiateWasm) {
        this.info("DosBox resolved");
        this.instantiateWasm = instantiateWasm;
        this.instance = new dosbox(this);
    };
    // Method `ondosbox` is called when
    // [Host](https://js-dos.com/6.22/docs/api/generate.html?page=js-dos-host) is resolved.
    // This method instaniate wasm dosbox module with `this` as emscripten
    // module object. It means that emscripten will call
    // `this.onRuntimeInitialized` when runtime will be ready
    DosModule.prototype.resolve = function () {
        var _this = this;
        if (!this.wdosboxUrl) {
            this.wdosboxUrl = "wdosbox.js";
        }
        if (!this.log) {
            /* tslint:disable:no-console */
            this.log = function (message) {
                return console.log(message);
            };
        }
        if (!this.canvas) {
            if (this.onerror !== undefined) {
                this.onerror("canvas field is required, but not set!");
            }
            return;
        }
        if (!this.onprogress) {
            this.ui = new js_dos_ui_1.DosUi(this);
            this.onprogress = function (stage, total, loaded) {
                if (_this.ui !== null) {
                    _this.ui.onprogress(stage, total, loaded);
                }
            };
        }
        // ### sdl defaults
        // DosModule overrides defaults for emscripten SDL wrapper
        // for maximum performance
        this.SDL = {
            defaults: {
                widht: 320,
                height: 200,
                copyOnLock: false,
                discardOnLock: true,
                opaqueFrontBuffer: false
            }
        };
        this.isValid = true;
    };
    // ### onRuntimeInitialized
    DosModule.prototype.onRuntimeInitialized = function () {
        var _this = this;
        var mainFn = function mainFn(args) {
            // When emscripten runtime is initialized and main
            // function is called:
            //
            // * DosModule detach [auto ui](https://js-dos.com/6.22/docs/api/generate.html?page=js-dos-ui)
            if (_this.ui !== null) {
                _this.ui.detach();
                _this.ui = null;
            }
            if (!args) {
                args = [];
            }
            if (_this.fs === null) {
                return new Promise(function (resolve, reject) {
                    reject("IllegalState: fs is null");
                });
            }
            _this.fs.chdir("/");
            // * Write default [dosbox.conf](https://js-dos.com/6.22/docs/api/generate.html?page=js-dos-conf)
            // file to user directory
            _this.fs.createFile("/home/web_user/.dosbox/dosbox-jsdos.conf", js_dos_conf_1.jsdosconf);
            // * Mount emscripten FS as drive c:
            args.unshift("-userconf", "-c", "mount c .", "-c", "c:");
            // * Run dosbox with passed arguments and resolve
            // [DosCommandInterface](https://js-dos.com/6.22/docs/api/generate.html?page=js-dos-ci)
            _this.callMain(args);
            return new Promise(function (resolve) {
                new js_dos_ci_1.DosCommandInterface(_this, function (ci) {
                    resolve(ci);
                });
            });
        };
        this.fs = new js_dos_fs_1.DosFS(this);
        this.onready({
            fs: this.fs,
            main: mainFn
        });
    };
    // ### registerTickListener
    // registred tick listener it will be called each frame
    DosModule.prototype.registerTickListener = function (listener) {
        this.tickListeners.push(listener);
    };
    // ### registerPauseListener
    // registred tick listener it will be called each frame
    DosModule.prototype.registerPauseListener = function (listener) {
        this.pauseListeners.push(listener);
    };
    // ### registerResumeListener
    // registred tick listener it will be called each frame
    DosModule.prototype.registerResumeListener = function (listener) {
        this.resumeListeners.push(listener);
    };
    // ### registerTerminateListener
    // registred tick listener it will be called each frame
    DosModule.prototype.registerTerminateListener = function (listener) {
        this.terminateListeners.push(listener);
    };
    // ### tick
    // tick is called internally each frame, no need to call
    // it manually
    DosModule.prototype.tick = function () {
        for (var _i = 0, _a = this.tickListeners; _i < _a.length; _i++) {
            var l = _a[_i];
            l();
        }
    };
    // ### pause
    // pause is called when dosbox tab became inactive
    DosModule.prototype.pause = function () {
        for (var _i = 0, _a = this.pauseListeners; _i < _a.length; _i++) {
            var l = _a[_i];
            l();
        }
    };
    // ### tick
    // resume is called when dosbox tab became active
    DosModule.prototype.resume = function () {
        for (var _i = 0, _a = this.resumeListeners; _i < _a.length; _i++) {
            var l = _a[_i];
            l();
        }
    };
    // ### tick
    // terminate is called when dosbox tab is closed
    DosModule.prototype.terminate = function () {
        for (var _i = 0, _a = this.terminateListeners; _i < _a.length; _i++) {
            var l = _a[_i];
            l();
        }
    };
    return DosModule;
}(js_dos_options_1.DosOptions);
exports.DosModule = DosModule;

},{"./js-dos-build":1,"./js-dos-ci":5,"./js-dos-conf":6,"./js-dos-fs":7,"./js-dos-options":10,"./js-dos-ui":11}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DosOptions = /** @class */function () {
    function DosOptions() {}
    return DosOptions;
}();
exports.DosOptions = DosOptions;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DosUi = /** @class */function () {
    function DosUi(dos) {
        this.overlay = null;
        this.loaderMessage = null;
        this.hidden = true;
        // ### Style
        /* tslint:disable:member-ordering */
        /* tslint:disable:max-line-length */
        this.css = "\n    .dosbox-container { position: relative; min-width: 320px; min-height: 200px; display: inline-block; }\n    .dosbox-overlay, .dosbox-loader { position: absolute; left: 0; right: 0; top: 0; bottom: 0; background-color: rgba(51, 51, 51, 0.7); }\n    .dosbox-start { text-align: center; position: absolute; left: 0; right: 0; bottom: 50%; color: #f80; font-size: 1.5em; text-decoration: underline; cursor: pointer; }\n    .dosbox-overlay a { color: #f80; }\n    .dosbox-powered { position: absolute; right: 1em; bottom: 1em; font-size: 0.8em; color: #9C9C9C; }\n    .dosbox-loader-message { text-align: center; position: absolute; left: 0; right: 0; bottom: 50%; margin: 0 0 -3em 0; box-sizing: border-box; color: #f80; font-size: 1.5em; }\n    @-moz-keyframes loading { 0% { left: 0; } 50% { left: 8.33333em; } 100% { left: 0; } } @-webkit-keyframes loading { 0% { left: 0; } 50% { left: 8.33333em; } 100% { left: 0; } } @keyframes loading { 0% { left: 0; } 50% { left: 8.33333em; } 100% { left: 0; } } .st-loader { width: 10em; height: 2.5em; position: absolute; top: 50%; left: 50%; margin: -1.25em 0 0 -5em; box-sizing: border-box; }\n    .st-loader:before, .st-loader:after { content: \"\"; display: block; position: absolute; top: 0; bottom: 0; width: 1.25em; box-sizing: border-box; border: 0.25em solid #f80; }\n    .st-loader:before { left: -0.76923em; border-right: 0; }\n    .st-loader:after { right: -0.76923em; border-left: 0; }\n    .st-loader .equal { display: block; position: absolute; top: 50%; margin-top: -0.5em; left: 4.16667em; height: 1em; width: 1.66667em; border: 0.25em solid #f80; box-sizing: border-box; border-width: 0.25em 0; -moz-animation: loading 1.5s infinite ease-in-out; -webkit-animation: loading 1.5s infinite ease-in-out; animation: loading 1.5s infinite ease-in-out; background: #f80; }\n    ";
        // ### Template
        /* tslint:disable:member-ordering */
        /* tslint:disable:max-line-length */
        this.overlayHtml = "\n        <div class=\"dosbox-loader\">\n            <div class=\"st-loader\">\n                <span class=\"equal\"></span>\n            </div>\n            <div class=\"dosbox-loader-message\"></div>\n        </div>\n        <div class=\"dosbox-powered\">\n            Powered by &nbsp;<a href=\"https://js-dos.com\">js-dos.com</a> (6.22)\n        </div>\n    ";
        this.dos = dos;
        this.canvas = dos.canvas;
        // ### How it works
        // This ui replace canvas element with div .dosbox-container,
        // that contains original canvas and .dosbox-overlay as children
        // You can change style of ui by editing css for this two classes
        try {
            if (document.getElementById("js-dos-ui-css") === null) {
                var style = document.createElement("style");
                style.id = "js-dos-ui-css";
                style.innerHTML = this.css;
                document.head.appendChild(style);
            }
            if (this.canvas.parentElement !== null && this.canvas.parentElement.className !== "dosbox-container") {
                var container_1 = document.createElement("div");
                container_1.className = "dosbox-container";
                var parent_1 = this.canvas.parentElement;
                parent_1.replaceChild(container_1, this.canvas);
                container_1.appendChild(this.canvas);
                var overlay = document.createElement("div");
                overlay.className = "dosbox-overlay";
                container_1.appendChild(overlay);
                overlay.innerHTML = this.overlayHtml;
            }
            var container = this.canvas.parentElement;
            if (container === null) {
                throw new Error("Illegal state, container is null");
            }
            this.overlay = this.childById(container, "dosbox-overlay");
            if (this.overlay === null) {
                throw new Error("Illegal state, overlay is null");
            }
            this.loaderMessage = this.childById(this.overlay, "dosbox-loader-message");
            this.hidden = true;
            this.show();
        } catch (e) {
            this.onprogress = this.onprogressFallback;
        }
    }
    DosUi.prototype.onprogress = function (stage, total, loaded) {
        var message = stage + " " + Math.round(loaded * 100 / total * 10) / 10 + "%";
        if (this.loaderMessage !== null) {
            this.loaderMessage.innerHTML = message;
        }
        this.dos.info(message);
        if (loaded >= total) {
            this.hide();
        } else {
            this.show();
        }
    };
    DosUi.prototype.detach = function () {
        this.hide();
        this.onprogress = this.onprogressFallback;
    };
    DosUi.prototype.hide = function () {
        if (this.hidden) {
            return;
        }
        this.hidden = true;
        if (this.overlay !== null) {
            this.overlay.setAttribute("style", "display: none");
        }
    };
    DosUi.prototype.show = function () {
        if (!this.hidden) {
            return;
        }
        this.hidden = false;
        if (this.overlay !== null) {
            this.overlay.setAttribute("style", "display: block");
        }
    };
    DosUi.prototype.onprogressFallback = function (stage, total, loaded) {
        this.dos.info(stage + " " + loaded * 100 / total + "%");
    };
    DosUi.prototype.childById = function (parent, className) {
        if (parent === null) {
            return null;
        }
        for (var i = 0; i < parent.childElementCount; ++i) {
            var child = parent.children[i];
            if (child.className === className) {
                return child;
            }
            child = this.childById(child, className);
            if (child !== null) {
                return child;
            }
        }
        return null;
    };
    return DosUi;
}();
exports.DosUi = DosUi;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var js_dos_cache_noop_1 = require("./js-dos-cache-noop");
// * `method` - "GET" | "POST"
// * `success` - callback when resource is downloaded
// * `progress` - callback for progress
// * `fail` - fail callback
// * `data` - data for POST request, should typeof `application/x-www-form-urlencoded`
// * `responseType` - XMLHttpRequestResponseType
// Class Xhr does not have any public methods
var Xhr = /** @class */function () {
    function Xhr(url, options) {
        var _this = this;
        this.xhr = null;
        this.total = 0;
        this.loaded = 0;
        this.resource = url;
        this.options = options;
        this.options.method = options.method || "GET";
        this.cache = options.cache || new js_dos_cache_noop_1.default();
        if (this.options.method === "GET") {
            this.cache.get(this.resource, function (data) {
                if (_this.options.success !== undefined) {
                    _this.options.success(data);
                }
            }, function () {
                _this.makeHttpRequest();
            });
        }
    }
    Xhr.prototype.makeHttpRequest = function () {
        var _this = this;
        this.xhr = new XMLHttpRequest();
        this.xhr.open(this.options.method || "GET", this.resource, true);
        if (this.options.method === "POST") {
            this.xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
        this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        var progressListner;
        if (typeof (progressListner = this.xhr).addEventListener === "function") {
            progressListner.addEventListener("progress", function (evt) {
                _this.total = evt.total;
                _this.loaded = evt.loaded;
                if (_this.options.progress) {
                    return _this.options.progress(evt.total, evt.loaded);
                }
            });
        }
        var errorListener;
        if (typeof (errorListener = this.xhr).addEventListener === "function") {
            errorListener.addEventListener("error", function (evt) {
                if (_this.options.fail) {
                    _this.options.fail(_this.resource, _this.xhr.status, "connection problem");
                    return delete _this.options.fail;
                }
            });
        }
        this.xhr.onreadystatechange = function () {
            return _this.onReadyStateChange();
        };
        if (this.options.responseType) {
            this.xhr.responseType = this.options.responseType;
        }
        this.xhr.send(this.options.data);
    };
    Xhr.prototype.onReadyStateChange = function () {
        var xhr = this.xhr;
        if (xhr.readyState === 4) {
            if (xhr.status === 200) {
                if (this.options.success) {
                    var total = Math.max(this.total, this.loaded);
                    if (this.options.progress !== undefined) {
                        this.options.progress(total, total);
                    }
                    if (this.options.method === "GET" && this.resource.indexOf("?") < 0) {
                        this.cache.put(this.resource, xhr.response, function () {});
                    }
                    return this.options.success(xhr.response);
                }
            } else if (this.options.fail) {
                this.options.fail(this.resource, xhr.status, "connection problem");
                return delete this.options.fail;
            }
        }
    };
    return Xhr;
}();
exports.Xhr = Xhr;

},{"./js-dos-cache-noop":3}],13:[function(require,module,exports){
"use strict";
// # Example
// ```javascript
// Dos(canvas).ready((fs, main) => {
//     fs.extract("digger.zip").then(() => {
//         main(["-c", "DIGGER.COM"])
//     });
// });
// ```
// Dos function is entry point that provides emulation layer.
// As emulation layer js-dos uses [DosBox ported to emscripten](https://github.com/dreamlayers/em-dosbox/#compiling).

Object.defineProperty(exports, "__esModule", { value: true });
// # Dos
var js_dos_cache_1 = require("./js-dos-cache");
var js_dos_host_1 = require("./js-dos-host");
var js_dos_module_1 = require("./js-dos-module");
var Dos = function Dos(canvas, options) {
    var promise = new Promise(function (resolve, reject) {
        var module = new js_dos_module_1.DosModule(canvas, resolve);
        if (!options) {
            options = {};
        }
        if (!options.onerror) {
            options.onerror = function (message) {
                /* tslint:disable:no-console */
                console.error(message);
                /* tslint:enable:no-console */
            };
        }
        Object.assign(module, options);
        // ### Error handling
        // Error handling should support both ways:
        //
        // * Through rejecting of promise
        // * Fire onerror function of DosOptions object
        var onerror = module.onerror;
        module.onerror = function (message) {
            reject(message);
            var fn = function fn() {
                if (onerror) {
                    onerror(message);
                    module.onerror = onerror;
                } else {
                    module.onerror = module.error;
                }
            };
            setTimeout(fn, 1);
        };
        module.resolve();
        if (!module.isValid) {
            return;
        }
        js_dos_cache_1.default(module, function (cache) {
            // See [Host](https://js-dos.com/6.22/docs/api/generate.html?page=js-dos-host)
            // to understand resolving of emulation layer (dosbox).
            js_dos_host_1.Host.resolveDosBox(module.wdosboxUrl, cache, module);
        });
    });
    // ### DosReadyPromise
    // Is a Promise object with additional method ready.
    // Method `ready` is just a wrapper over `then` method that
    // split resolved object into meaningful parts.
    var dosReadyPromise = promise;
    dosReadyPromise.ready = function (onready) {
        dosReadyPromise.then(function (runtime) {
            onready(runtime.fs, runtime.main);
        });
        return dosReadyPromise;
    };
    return dosReadyPromise;
};
exports.default = Dos;
window.Dos = Dos;

},{"./js-dos-cache":4,"./js-dos-host":8,"./js-dos-module":9}],14:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":17}],15:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],16:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],17:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":16,"_process":18,"inherits":15}],18:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var do_1 = require("./do");
// Compare
// =======
// Compare image from url, and screenshot from DosBox
function compareAndExit(imageUrl, ci, done) {
    compare(imageUrl, ci, function (wrong) {
        assert.equal(0, wrong);
        ci.exit();
        done();
    });
}
exports.compareAndExit = compareAndExit;
var compare = function compare(imageUrl, ci, callback) {
    do_1.doThen(ci.screenshot(), function (actualUrl) {
        var img = new Image();
        img.onload = function () {
            assert(img.width === ci.width(), "Invalid width: " + ci.width() + ", should be " + img.width);
            assert(img.height === ci.height(), "Invalid height: " + ci.height() + ", should be " + img.height);
            var canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            var expected = ctx.getImageData(0, 0, img.width, img.height).data;
            var actualImage = new Image();
            actualImage.onload = function () {
                /*
                document.body.appendChild(img); // for comparisons
                var div = document.createElement('div');
                div.innerHTML = '^=expected, v=actual';
                document.body.appendChild(div);
                document.body.appendChild(actualImage); // to grab it for creating the test reference
                */
                var actualCanvas = document.createElement("canvas");
                actualCanvas.width = actualImage.width;
                actualCanvas.height = actualImage.height;
                var actualCtx = actualCanvas.getContext("2d");
                actualCtx.drawImage(actualImage, 0, 0);
                var actual = actualCtx.getImageData(0, 0, actualImage.width, actualImage.height).data;
                var total = 0;
                var width = img.width;
                var height = img.height;
                for (var x = 0; x < width; x++) {
                    for (var y = 0; y < height; y++) {
                        total += Math.abs(expected[y * width * 4 + x * 4 + 0] - actual[y * width * 4 + x * 4 + 0]);
                        total += Math.abs(expected[y * width * 4 + x * 4 + 1] - actual[y * width * 4 + x * 4 + 1]);
                        total += Math.abs(expected[y * width * 4 + x * 4 + 2] - actual[y * width * 4 + x * 4 + 2]);
                    }
                }
                // floor, to allow some margin of error for antialiasing
                var wrong = Math.floor(total / (img.width * img.height * 3));
                callback(wrong);
            };
            actualImage.src = actualUrl;
        };
        img.src = imageUrl;
    });
};

},{"./do":20,"assert":14}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
// Do
// ==
// We use this functions to avoid problem of throwing,
// exceptions inside promise.
// Mocha can't handle exceptions if they are throwed in promise
function doThen(promise, fn) {
    promise.then(function (v) {
        var topFn = function topFn() {
            fn(v);
        };
        setTimeout(topFn, 1);
    });
}
exports.doThen = doThen;
function doCatch(promise, fn) {
    promise.catch(function (v) {
        var topFn = function topFn() {
            fn(v);
        };
        setTimeout(topFn, 1);
    });
}
exports.doCatch = doCatch;
function doNext(promise, fn) {
    doThen(promise, fn);
    doCatch(promise, function (msg) {
        return assert.fail(msg);
    });
}
exports.doNext = doNext;
function doReady(promise, fn) {
    doThen(promise, function (runtime) {
        fn(runtime.fs, runtime.main);
    });
    doCatch(promise, function (msg) {
        return assert.fail(msg);
    });
}
exports.doReady = doReady;

},{"assert":14}],21:[function(require,module,exports){
"use strict";
/* tslint:disable:max-line-length */
/* tslint:disable:no-console */

Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var js_dos_1 = require("../js-dos-ts/js-dos");
var js_dos_cache_noop_1 = require("../js-dos-ts/js-dos-cache-noop");
var js_dos_host_1 = require("../js-dos-ts/js-dos-host");
var compare_1 = require("./compare");
var do_1 = require("./do");
suite("js-dos-host");
test("loader should notify about error if wasm is not supported", function (done) {
    var oldValue = js_dos_host_1.Host.wasmSupported;
    js_dos_host_1.Host.wasmSupported = false;
    js_dos_host_1.Host.resolveDosBox("wrongurl.js", new js_dos_cache_noop_1.default(), {
        onerror: function onerror(message) {
            js_dos_host_1.Host.wasmSupported = oldValue;
            assert.equal("WebAssembly is not supported, can't resolve wdosbox", message);
            done();
        }
    });
});
test("loader should notify about error, if it can't download wdosbox", function (done) {
    js_dos_host_1.Host.resolveDosBox("wrongurl.js", new js_dos_cache_noop_1.default(), {
        onerror: function onerror(message) {
            assert.equal("Can't download wasm, code: 404, message: connection problem, url: wrongurl.wasm.js", message);
            done();
        }
    });
});
test("loader should show progress loading and use cache", function (done) {
    var isGET = false;
    var isPUT = false;
    var TestCache = /** @class */function () {
        function TestCache() {}
        TestCache.prototype.put = function (key, data, onflush) {
            isPUT = isPUT || key === "/wdosbox.wasm.js" && data instanceof ArrayBuffer && data.byteLength > 0;
            onflush();
        };
        TestCache.prototype.get = function (key, ondata, onerror) {
            isGET = isGET || key === "/wdosbox.wasm.js";
            onerror("not in cache");
        };
        TestCache.prototype.forEach = function (each, onend) {
            onend();
        };
        return TestCache;
    }();
    var lastLoaded = -1;
    js_dos_host_1.Host.resolveDosBox("/wdosbox.js", new TestCache(), {
        onprogress: function onprogress(stage, total, loaded) {
            console.log(stage, total, loaded);
            assert.equal(true, loaded <= total, loaded + "<=" + total);
            assert.equal(true, lastLoaded <= loaded, lastLoaded + "<=" + loaded);
            lastLoaded = loaded;
        },
        ondosbox: function ondosbox(dosbox, instantiateWasm) {
            assert.ok(isGET);
            assert.ok(isPUT);
            done();
        },
        onerror: function onerror(message) {
            assert.fail();
        }
    });
});
test("loader should never load twice wdosbox", function (done) {
    js_dos_host_1.Host.resolveDosBox("/wdosbox.js", new js_dos_cache_noop_1.default(), {
        onprogress: function onprogress(stage, total, loaded) {
            assert.fail();
        },
        ondosbox: function ondosbox(dosbox, instantiateWasm) {
            done();
        },
        onerror: function onerror(message) {
            assert.fail();
        }
    });
});
test("loader should fire event when wdosbox is loaded", function (done) {
    js_dos_host_1.Host.resolveDosBox("/wdosbox.js", new js_dos_cache_noop_1.default(), {
        ondosbox: function ondosbox(dosbox, instantiateWasm) {
            assert.ok(dosbox);
            assert.ok(instantiateWasm);
            done();
        },
        onerror: function onerror(message) {
            assert.fail();
        }
    });
});
suite("js-dos");
test("js-dos can't start without canvas (listener style)", function (done) {
    js_dos_1.default(null, {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.equal("canvas field is required, but not set!", message);
            done();
        }
    });
});
test("js-dos can't start without canvas (promise style)", function (done) {
    var dos = js_dos_1.default(null, {
        wdosboxUrl: "/wdosbox.js"
    });
    do_1.doCatch(dos, function (message) {
        assert.equal("canvas field is required, but not set!", message);
        done();
    });
    do_1.doThen(dos, function () {
        assert.fail();
    });
});
test("js-dos can't start without canvas (ready style)", function (done) {
    var dos = js_dos_1.default(null, {
        wdosboxUrl: "/wdosbox.js"
    });
    var promise = dos.ready(function (fs, main) {
        var fn = function fn() {
            return assert.fail();
        };
        setTimeout(fn, 1);
    });
    do_1.doCatch(promise, function (message) {
        assert.equal("canvas field is required, but not set!", message);
        done();
    });
});
test("js-dos should start with canvas", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js"
    });
    do_1.doReady(dos, function (fs, main) {
        do_1.doNext(main([]), function (ci) {
            ci.exit();
            done();
        });
    });
});
test("js-dos can take screenshot of canvas", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js"
    });
    do_1.doReady(dos, function (fs, main) {
        do_1.doNext(main([]), function (ci) {
            compare_1.compareAndExit("init.png", ci, done);
        });
    });
});
suite("js-dos-fs");
test("js-dos-fs createFile error handling", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.equal(message, "Can't create file '', because file name is empty");
            done();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("", "");
    });
});
test("js-dos-fs createFile error handling 2", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.equal(message, "Can't create file '/home/', because file name is empty");
            done();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("/home/", "");
    });
});
test("js-dos-fs can create file", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("/wiki/musk", wikiElonMusk);
        do_1.doNext(main(), function (ci) {
            do_1.doNext(ci.shell("type wiki\\musk"), function () {
                compare_1.compareAndExit("elonmusk.png", ci, done);
            });
        });
    });
});
test("js-dos-fs can create file (windows path)", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("C:\\wiki\\musk", wikiElonMusk);
        do_1.doNext(main(), function (ci) {
            do_1.doNext(ci.shell("type wiki\\musk"), function () {
                compare_1.compareAndExit("elonmusk.png", ci, done);
            });
        });
    });
});
test("js-dos-fs clearing IDBFS db", function (done) {
    var request = indexedDB.deleteDatabase("/test");
    request.onerror = function (event) {
        console.error(event);
        assert.fail();
    };
    request.onsuccess = function (event) {
        done();
    };
});
test("js-dos-fs can mount archive on persistent point [empty db]", function (done) {
    var isOnProgress = false;
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        },
        onprogress: function onprogress(stage, total, loaded) {
            isOnProgress = true;
        }
    });
    do_1.doReady(dos, function (fs, main) {
        do_1.doNext(fs.extract("digger.zip", "/test"), function () {
            do_1.doNext(main(), function (ci) {
                do_1.doNext(ci.shell("dir test"), function () {
                    assert.ok(isOnProgress);
                    compare_1.compareAndExit("pesistent-mount.png", ci, done);
                });
            });
        });
    });
});
test("js-dos-fs can mount archive on persistent point [existent db]", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        },
        onprogress: function onprogress(stage, total, loaded) {
            assert.fail();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        do_1.doNext(fs.extract("digger.zip", "/test"), function () {
            do_1.doNext(main(), function (ci) {
                do_1.doNext(ci.shell("dir test"), function () {
                    compare_1.compareAndExit("pesistent-mount.png", ci, done);
                });
            });
        });
    });
});
suite("js-dos");
test("js-dos should provide user level dosbox.conf", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("dosbox.conf", "\n        [autoexec]\n        mount c .\n        c:\n        cd HOME\n        cd WEB_USER\n        cd DOSBOX~1\n        type dosbox~1.con\n        ");
        do_1.doNext(main(["-conf", "dosbox.conf"]), function (ci) {
            compare_1.compareAndExit("jsdos-conf.png", ci, done);
        });
    });
});
test("js-dos can create and read dosbox.conf", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js",
        onerror: function onerror(message) {
            assert.fail();
        }
    });
    do_1.doReady(dos, function (fs, main) {
        fs.createFile("dosbox.conf", "\n            [autoexec]\n            mount c .\n            c:\n            type dosbox~1.con\n        ");
        do_1.doNext(main(["-conf", "dosbox.conf"]), function (ci) {
            compare_1.compareAndExit("dosboxconf.png", ci, done);
        });
    });
});
test("js-dos can run digger.zip", function (done) {
    var dos = js_dos_1.default(document.getElementById("canvas"), {
        wdosboxUrl: "/wdosbox.js"
    });
    do_1.doReady(dos, function (fs, main) {
        do_1.doNext(fs.extract("digger.zip"), function () {
            do_1.doNext(main(["DIGGER.COM"]), function (ci) {
                var fn = function fn() {
                    compare_1.compareAndExit("digger.png", ci, done);
                    // saveImage(ci);
                };
                setTimeout(fn, 5000);
            });
        });
    });
});
var saveImage = function saveImage(ci) {
    ci.screenshot().then(function (data) {
        var w = window.open("about:blank", "image from canvas");
        w.document.write("<img src='" + data + "' alt='from canvas'/>");
    });
};
var wikiElonMusk = "\nElon Reeve Musk FRS (/\u02C8i\u02D0l\u0252n/; born June 28, 1971) is a\ntechnology entrepreneur and engineer.[10][11][12]\nHe holds South African, Canadian, and U.S. citizenship\nand is the founder, CEO, and lead designer of SpaceX;\n[13] co-founder, CEO, and product architect of Tesla, Inc.;\n[14] co-founder and CEO of Neuralink; and co-founder of PayPal.\nIn December 2016, he was ranked 21st on the Forbes list of\nThe World's Most Powerful People.[15] As of October 2018,\nhe has a net worth of $22.8 billion and is listed by Forbes\nas the 54th-richest person in the world.[16]\nBorn and raised in Pretoria, South Africa, Musk moved to\nCanada when he was 17 to attend Queen's University.\nHe transferred to the University of Pennsylvania two years\nlater, where he received an economics degree from\nthe Wharton School and a degree in physics from the College\nof Arts and Sciences. He began a Ph.D.\nin applied physics and material sciences at Stanford University\nin 1995 but dropped out after two days to pursue\nan entrepreneurial career. He subsequently co-founded Zip2, a\nweb software company, which was acquired by Compaq\nfor $340 million in 1999. Musk then founded X.com, an online bank.\nIt merged with Confinity in 2000 and later that\nyear became PayPal, which was bought by eBay for $1.5 billion\nin October 2002.[17][18][19][20]\n";

},{"../js-dos-ts/js-dos":13,"../js-dos-ts/js-dos-cache-noop":3,"../js-dos-ts/js-dos-host":8,"./compare":19,"./do":20,"assert":14}]},{},[21])

//# sourceMappingURL=test.js.map
